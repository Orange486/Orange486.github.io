{"meta":{"title":"Orange","subtitle":null,"description":null,"author":"Orange","url":"https://orange486.com"},"pages":[{"title":"","date":"2019-09-06T13:09:46.045Z","updated":"2019-09-06T13:09:46.045Z","comments":true,"path":"404/index.html","permalink":"https://orange486.com/404/index.html","excerpt":"","text":"404 L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});"},{"title":"Me","date":"2019-08-31T09:57:35.000Z","updated":"2019-09-01T04:38:13.182Z","comments":true,"path":"about/index.html","permalink":"https://orange486.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"JSP的九大内置对象","slug":"JSP的九大内置对象","date":"2019-10-19T07:59:41.000Z","updated":"2019-10-19T09:25:29.222Z","comments":true,"path":"2019/10/19/JSP的九大内置对象/","link":"","permalink":"https://orange486.com/2019/10/19/JSP的九大内置对象/","excerpt":"","text":"​ 每个jsp页面在第一次被访问时，WEB容器会把请求交给JSP引擎去处理。JSP引擎先将JSP翻译成一个_JSPServlet(本质也是Servlet)，然后按照servlet的调用方式来进行调用。 由于JSP第一次访问时会翻译成servlet，所以第一次访问会比较慢，但第二次访问，如果JSP引擎发现现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。 JSP引擎在调用JSP对应的jspServlet时，会创建9个与web开发相关的对象供 -jspServlet使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相对应的变量，开发人员在JSP页面中通过这些变量可以快速获得这9大对象的引用。（By__博客，孤傲苍狼） 对象 描述 request HttpServletRequest类的实例 response HttpServletResponse类的实例 session HttpSession类的实例 application SercletContext类的实例，与应用上下文有关 pageContext pageContext类的实例，提供JSP页面所有对象及命名空间的访问 page 类似于Java类中的this关键字 out PrintWriter类的实例，用于把结果输出至网页上 config ServletConfig类的实例 execption Exception类的对象，代表发生错误的JSP页面对应的异常对象 request对象 1每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。 response对象 1当服务器创建request对象时会同时创建用于响应这个客户端的response对象。 out对象 1out对象用来在response对象中写入内容。 session对象 12session对象时javax.servlet,http.HttpSession类的实例。和Java Servlet中的session（隐式对象）对应一致的行为。session对象用来跟踪在各个客户端请求间的会话。一次会话是从客户端打开浏览器开始到客户端关闭浏览器结束。 application对象 1application对象直接包装了servlet的servletContext类的对象，是javax.servlet.ServletConext类的实例。通过向application中添加属性，则所有组成web应用的JSP文件和Servlet都能访问到这些属性。 config对象 1config对象时javax.servlet.ServletConfig类的实例，直接包装了servlet的ServletConfig类的对象。这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 page对象 1这个对象就是页面实例的引用。它可以被看成是整个JSP页面的代表。page对象就是this对象的同义词。 execption对象 1execption对象包装了从先前页面抛出的异常信息。它通常被用来产生对出错条件的适当响应。 pageContext对象 12345678910pageContext对象时javax》servlet.jsp.PageContext类的实例。1.可以用它获取其他八大内置对象： out pageContext.getOut(); request pageContext.getRequest(); response pageContext.getResponse(); session pageContext.getSession(); application pageContext.getSession(); config pageContext.getConfig(); exception pageContext.getException(); page pageContext.getPage(); 四个域对象 作用范围 pageContext对象 page域：只能在当前jsp页面使用 request对象 request域：只能在同一个请求中使用这（转发） session对象 session：只能在同一个会话（当前浏览器） application对象 sontext域：只能在同一个weby应用中使用（全局） 域对象方法 setAttribute(“name”,Object);保存数据 getAttribute(“name”);获取数据 removeAttribute(“name”);清楚数据","categories":[],"tags":[],"keywords":[]},{"title":"web项目页面跳转失败","slug":"web项目页面跳转失败","date":"2019-09-24T07:31:14.000Z","updated":"2019-09-24T07:40:30.610Z","comments":true,"path":"2019/09/24/web项目页面跳转失败/","link":"","permalink":"https://orange486.com/2019/09/24/web项目页面跳转失败/","excerpt":"","text":"​ 在学习JavaWeb项目的时候有时页面跳转失败，自己查了半天bug。大部分情况是路径写错了，还有两次bug找的我脑壳疼，一个是同桌的，他是因为服务器缓存原因，上次的路径信息重启服务器后仍然留着，导致他路径跳转很奇怪。还有一个是自己的，想点击a标签，通过点击事件跳转，一直没跳到我想要的页面，原因是我写的href=“”，就算不想通过a标签跳转，也要写href=”#”不能为空，执行顺序先是绑定的事件然后是href地址。","categories":[],"tags":[],"keywords":[]},{"title":"接口与抽象类的区别","slug":"接口与抽象类的区别","date":"2019-09-19T00:49:22.000Z","updated":"2019-09-19T00:56:15.697Z","comments":true,"path":"2019/09/19/接口与抽象类的区别/","link":"","permalink":"https://orange486.com/2019/09/19/接口与抽象类的区别/","excerpt":"","text":"1.接口中全是抽象方法，抽象类中可以有非抽象方法。2.抽象只能继承一个，接口可以实现多个。3.接口只能有静态常量，抽象类中都可以有。4.接口是一种全是抽象方法的抽象类。都不能被实例化。","categories":[],"tags":[],"keywords":[]},{"title":"String,StringBuffer,StringBulider的区别","slug":"String-StringBuffer-StringBulider的区别","date":"2019-09-07T03:43:05.000Z","updated":"2019-09-07T04:05:50.409Z","comments":true,"path":"2019/09/07/String-StringBuffer-StringBulider的区别/","link":"","permalink":"https://orange486.com/2019/09/07/String-StringBuffer-StringBulider的区别/","excerpt":"","text":"1234String类是字符串常量类，一旦定义不可以修改（①）。StringBuffer和StringBuffer实现了字符串的缓区，它们的内容是可以任意改变的。做简单字符串操作时选择String好一些，如果做大量的字符串拼接操作时，StringBuffer和StringBuilder的效率更高，StringBuilder的效率比StringBuffer的效率还要高，但StringBuilder是线程不安全的（②）。 1234567①： String str1=\"cxk\";//\"cxk\"在常量池中 String str2=new String(\"cxk\");//\"cxk\"在堆内存中②： 线程安全是指多线程访问同一代码，不会产生不确定的结果。 如果写了一个全局范围的StringBuffer和StringBuilder，两个线程不可以同时修改StringBufffer中的内 容，可以同时修改StringBuilder的内容。（与synchronized有关）","categories":[],"tags":[],"keywords":[]},{"title":"笔记二，==与equals的区别","slug":"笔记二，==与equals区别","date":"2019-09-03T12:57:10.000Z","updated":"2019-09-04T11:27:21.580Z","comments":true,"path":"2019/09/03/笔记二，==与equals区别/","link":"","permalink":"https://orange486.com/2019/09/03/笔记二，==与equals区别/","excerpt":"","text":"==比较的是内存地址，因为基本数据类型没有方法，所以在比较基本数据类型的时候，使用==进行比较，由于栈内容的特点（①），只要基本数据类型的值一样那么他们的地址就相同。equals方法是Object类的方法，底层的实现源码也是==方法。如果没有重写equals方法（②），比较的还是两个对象的地址。只有你重写了该引用数据类型的equals方法才会按照你的方式比较。例如String类，String类已经重写了equals方法，按照字符串的内容进行比较，内容相等即两个对象相等。 ①：栈：保存所有运行时的方法，所有的基本数据类型的数据和变量，以及引用数据类型的变量。 特点：（1）先进后出 （2）当方法执行完之后所有的局部变量都会被回收。运行速度快。 （3）int a = 3 ; 在栈中定义变量放进去，然后去栈中寻找10，如果有，a指向它，如果没有在顶上开辟 一个地址存放10，让a指向它。 ②：在Java中如果认为两个对象相等，那么hashcode值也相等，因此重写equals方法时，也要重写hashCode方 法。注：如果两个对象的hashcode值相等，equals方法不一定相等（hashcode值计算方法会有差异）。 equals方法相等，hashcode值一定相等。","categories":[],"tags":[],"keywords":[]},{"title":"笔记一，String转换数组","slug":"笔记一，String转换数组","date":"2019-09-03T11:09:20.000Z","updated":"2019-09-03T11:15:37.863Z","comments":true,"path":"2019/09/03/笔记一，String转换数组/","link":"","permalink":"https://orange486.com/2019/09/03/笔记一，String转换数组/","excerpt":"","text":"String与byte数组的转换123456byte[] b = &#123; 78, 56, 67 &#125;;String str = new String(b, 0, b.length);String str = \"cxk会ctrl\";byte[] b = str.getBytes();System.out.println(Arrays.toString(b)); String与char数组的转换123456char[] ch = &#123; 'c', 'x', 'k' &#125;;String str = new String(ch, 0, ch.length); String str = \"cxk会ctrl\";char[] b = str.toCharArray();System.out.println(Arrays.toString(b)); String与int数组的转换1234567891011121314151617int[] in = &#123; 23, 45, 96, 7, &#125;;StringBuffer sb = new StringBuffer();for (int i = 0; i &lt; in.length; i++) &#123; sb.append(in[i]);//sb.append(in[i]+\";\");也可以在每个数字之间加个分隔符&#125; String str = \"6921168509256\";int[] arr = new int[str.length()];for (int i = 0; i &lt; str.length(); i++) &#123; // 因为字符串有可能有非数字元素，要处理异常 // substring进行字符串截取 try &#123; arr[i] = Integer.parseInt(str.substring(i, i + 1)); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"我的第一篇测试文章","slug":"我的第一篇测试文章","date":"2019-08-31T07:11:59.000Z","updated":"2019-08-31T07:18:50.361Z","comments":true,"path":"2019/08/31/我的第一篇测试文章/","link":"","permalink":"https://orange486.com/2019/08/31/我的第一篇测试文章/","excerpt":"","text":"2019年，8月，31日，下午3点钟，晴。这是个值得记录的日子，我的第一篇文章发布，就是这个。（虽然很简陋）","categories":[],"tags":[],"keywords":[]}]}